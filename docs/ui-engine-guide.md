# Использование UI engine

## Основные типы элементов

UI engine предоставляет некоторые элементы из коробки.  
Вы можете использовать их напрямую, либо наследоваться от них.

### AbstractElement

Все элементы наследуются от AbstractElement, а следовательно имеют все его свойства.

#### offset

Самый простой способ управлять положением элементов - сдвигать их по пикселям.

`offset = V3(1.0, 2.0)` сдвинет элемент вправо на 1 пиксель и вниз на 2.

Однако, абсолютное измерение offset полезно только для небольших корректировок позиции элемента.  
Для расположения элементов на экране / внутри других элементов следует использовать align и origin.

#### align

Сдвиг элемента в процентах относительно родителя (или экрана)

Один из главных концептов UI engine - ориджины и алигны.
Они служат для упрощения разработки адаптивных интерфейсов:
У всех игроков разные размеры экрана и интерфейса, поэтому сдвиги в пикселях не работают для всех.

Align позволяет расположить элемент в той или иной точке родителя в процентах, а не в абсолютных пикселях.

В объекте Relative есть 99% того, что вы когда-либо будете использовать для значений align и origin

К примеру `Relative.CENTER` равен `V3(0.5, 0.5)`,
что соответствует сдвигу на 50% вправо и вниз относительно размера родителя

#### origin

Сдвиг элемента в процентах относительно самого себя.

origin - своего рода "точка крепления" элемента к родителю.  
Изначально origin равен 0; 0 = `Relative.TOP_LEFT`, элемент крепится к родителю за свой левый верхний угол

Например чтобы центрировать элемент по обеим осям,
нужно поставить и `align = Relative.CENTER`, и `origin = Relative.CENTER`

Песочница для настройки offset, align и origin, доступна [здесь](https://delfikpro.github.io/origin).

#### scale

Элементы можно увеличивать и уменьшать в процентах, используя свойство `scale`.

Обратите внимание, что при изменении scale элементов, реализующих интерфейс Parent,
размер их дочерних элементов также меняется.

#### rotation

Элементы можно поворачивать.

`rotation.angle` меняет угол поворота в градусах.

Поля `x`, `y` и `z` отвечают за ось вращения.  
Изначальная ось = 0; 0; 1 - вращение по часовой стрелке по оси Z,
направленной перпендикулярно плоскости экрана в сторону зрителя

#### color

Элементам можно менять цвет.

UI engine предоставляет три заранее заготовленных цвета: TRANSPARENT, BLACK и WHITE.

Вы можете создавать свои цвета, вызывая различные конструкторы класса `Color`, например:

```kotlin
 element.color = Color(red = 255, green = 100, blue = 0, alpha = 0.5)
```

Вы можете изменять как отдельные компоненты цвета у элементов, так и цвет целиком

```kotlin
 element.color.alpha = 1.0
 element.color.red = 0
 element.color = WHITE
```

#### onClick и onHover

Элементам (как в HUD, так и в мире) можно добавить слушатели наведения и кликов.

onClick имеет тип `ClickHandler` и принимает кнопку, состояние которой изменилось,
и новое состояние (нажата/отпущена)

onHover имеет тип `HoverHandler` и принимает состояние наведения (есть/нет)

Оба слушателя вызываются как при наводке/нажатии мыши, так и при отводке/отжатии.

#### beforeRender и afterRender

В элементы можно добавлять код, который будет выполняться до рендера и после.

Например, чтобы голограмма была видна сквозь стены, контексту можно добавить следующее:

```kotlin
 context3d.beforeRender = {
     GlStateManager.disableDepth()
 }
 context.afterRender = {
     GlStateManager.enableDepth()
 }
```

### TextElement

Элемент, использующийся для рендера текста.  
Вы можете менять содержимое элемента, меняя свойство `content`.  
Ширина элемента будет изменяться в соответствии с контентом.

У текста есть свойство `autoFit`. Если его включить, то текст будет уменьшаться / увеличиваться
в соответствии с шириной элемента-родителя.

Обратите внимание, что если вы используете цветовые коды в содержимом текста, то они будут заменять цвет,
заданный свойством `color` у элемента, но не прозрачность.

### RectangleElement

Двухмерные прямоугольники могут содержать внутри себя дочерние элементы,
что делает их невероятно полезными при разработке интерфейсов.

У прямоугольников, помимо основных свойств элемента, есть свойства size, texture и children

#### size

Вы можете указать размер прямоугольника в пикселях, меняя параметр size.

Положительный размер увеличивает прямоугольник вправо и вниз, отрицательный - влево и вверх.

#### texture

Используя прямоугольники, можно рендерить на экране текстуры.

Параметр texture имеет тип ResourceLocation. Например, чтобы отрендерить текстурку,
путь к которой в ресурс-паке выглядит как `assets/minecraft/textures/entity/chest/normal_double.png`,
нужно создать ResourceLocation со следующими параметрами:

```kotlin
 textureLocation = clientApi.resourceManager().getLocation("minecraft", "textures/entity/chest/normal_double.png")
```

Стандартные настройки прямугольника рендерят текстурку целиком.  
Чтобы отрендерить некоторую часть текстуры, нужно указать размер текстуры - `textureScale` (стандартный размер - 1 на 1)
,
а также текстурные координаты: `textureFrom` - откуда, и `textureWidth` - размер в пикселях.

Например, чтобы отрендерить крышку двойного сундука, можно использовать следующие координаты:  
Стандартный размер текстуры двойного сундука - 128х64, будем использовать такой же textureScale для удобства  
Крышка сундука начинается на координатах 14; 0, а её размер - 30х14.

Таким образом:

```kotlin
 textureScale = V2(128.0, 64.0)
 textureFrom = V2(14.0, 0.0)
 textureWidth = V2(30.0, 14.0)
```

#### children

RectangleElement реализует интерфейс Parent, а следовательно может содержать дочерние элементы.

Добавить дочерний элемент можно методом `addChild(...)`, удалить - `removeChild(...)`

Align дочерних элементов задаётся относительно размера самого RectangleElement, подробнее см. align.

Дочерние элементы отображаются в том порядке, в котором они были добавлены.

Дочерние элементы наследуют все трансформации родителя. Offset=0 для дочернего элемента означает,
что он будет отображён в левом верхнем углу родителя.

В качестве примера приведён код, добавляющий в центр экрана прямоугольник,
в левом верхнем углу которого есть надпись "Привет, мир!"

```kotlin
UIEngine.overlayContext.addChild(rectangle {
  size = V3(100.0, 50.0)
  color = BLACK
  align = Relative.CENTER
  origin = Relative.CENTER
  addChild(text {
      content = "Привет, мир!"
      offset = V3(1.0, 1.0)
  })
})
```

### ItemElement

В UI engine можно рендерить предметы.

У предмета есть единственное свойство - item, отвечающее за отображаемый предмет.  
Данное поле может принимать значение null, в этом случае предмет не будет рендерится.

Размер (size) всех ItemElement - 16х16 пикселей

Свойство color не работает с некоторыми предметами.

### Context3D

Вы можете рендерить элементы UI engine как голограммы в мире, создав Context3D
и добавив его в `UIEngine.worldContexts`.

Свойство `offset` 3d-контекста напрямую управляет координатами голограммы в мире.

Изначальный поворот всех мировых контекстов - в сторону yaw = 0
